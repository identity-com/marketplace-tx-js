<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>escrow.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="InMemoryNonceManager.html">InMemoryNonceManager</a><ul class='methods'><li data-type='method'><a href="InMemoryNonceManager.html#clearAccounts">clearAccounts</a></li><li data-type='method'><a href="InMemoryNonceManager.html#getNonceForAccount">getNonceForAccount</a></li><li data-type='method'><a href="InMemoryNonceManager.html#releaseAccountNonce">releaseAccountNonce</a></li><li data-type='method'><a href="InMemoryNonceManager.html#releaseAccountNonces">releaseAccountNonces</a></li></ul></li><li><a href="module.exports_module.exports.html">exports</a></li><li><a href="module-support_errors-InvalidNonceError.html">InvalidNonceError</a></li></ul><h3>Modules</h3><ul><li><a href="module-escrow.html">escrow</a><ul class='methods'><li data-type='method'><a href="module-escrow.html#.calculatePlacementId">calculatePlacementId</a></li><li data-type='method'><a href="module-escrow.html#.place">place</a></li><li data-type='method'><a href="module-escrow.html#.placeBatch">placeBatch</a></li><li data-type='method'><a href="module-escrow.html#.refund">refund</a></li><li data-type='method'><a href="module-escrow.html#.refundBatch">refundBatch</a></li><li data-type='method'><a href="module-escrow.html#.release">release</a></li><li data-type='method'><a href="module-escrow.html#.releaseBatch">releaseBatch</a></li><li data-type='method'><a href="module-escrow.html#.setFeeRate">setFeeRate</a></li><li data-type='method'><a href="module-escrow.html#.setTimeoutThreshold">setTimeoutThreshold</a></li><li data-type='method'><a href="module-escrow.html#.timeoutThreshold">timeoutThreshold</a></li><li data-type='method'><a href="module-escrow.html#.verify">verify</a></li><li data-type='method'><a href="module-escrow.html#.verifyBatch">verifyBatch</a></li><li data-type='method'><a href="module-escrow.html#.verifyPlacement">verifyPlacement</a></li><li data-type='method'><a href="module-escrow.html#~addPlacementReturnValue">addPlacementReturnValue</a></li><li data-type='method'><a href="module-escrow.html#~createEscrowPlaceTransactions">createEscrowPlaceTransactions</a></li><li data-type='method'><a href="module-escrow.html#~normalizeScopeRequestId">normalizeScopeRequestId</a></li></ul></li><li><a href="module-idvRegistry.html">idvRegistry</a><ul class='methods'><li data-type='method'><a href="module-idvRegistry.html#.exists">exists</a></li><li data-type='method'><a href="module-idvRegistry.html#.get">get</a></li><li data-type='method'><a href="module-idvRegistry.html#.set">set</a></li><li data-type='method'><a href="module-idvRegistry.html#~assertIdvRegistryRecord">assertIdvRegistryRecord</a></li><li data-type='method'><a href="module-idvRegistry.html#~mapIdvRegistryRecord">mapIdvRegistryRecord</a></li></ul></li><li><a href="module-ontology.html">ontology</a><ul class='methods'><li data-type='method'><a href="module-ontology.html#.add">add</a></li><li data-type='method'><a href="module-ontology.html#.deprecate">deprecate</a></li><li data-type='method'><a href="module-ontology.html#.deprecateById">deprecateById</a></li><li data-type='method'><a href="module-ontology.html#.getAll">getAll</a></li><li data-type='method'><a href="module-ontology.html#.getById">getById</a></li><li data-type='method'><a href="module-ontology.html#.getByTypeNameVersion">getByTypeNameVersion</a></li><li data-type='method'><a href="module-ontology.html#.getIdByTypeNameVersion">getIdByTypeNameVersion</a></li><li data-type='method'><a href="module-ontology.html#.parseExternalId">parseExternalId</a></li><li data-type='method'><a href="module-ontology.html#.parseExternalId">parseExternalId</a></li><li data-type='method'><a href="module-ontology.html#~assertCredentialItem">assertCredentialItem</a></li><li data-type='method'><a href="module-ontology.html#~mapCredentialItemRecord">mapCredentialItemRecord</a></li></ul></li><li><a href="module-pricing.html">pricing</a><ul class='methods'><li data-type='method'><a href="module-pricing.html#.deletePrice">deletePrice</a></li><li data-type='method'><a href="module-pricing.html#.getAllPrices">getAllPrices</a></li><li data-type='method'><a href="module-pricing.html#.getPrice">getPrice</a></li><li data-type='method'><a href="module-pricing.html#.setPrice">setPrice</a></li><li data-type='method'><a href="module-pricing.html#~assertPrice">assertPrice</a></li><li data-type='method'><a href="module-pricing.html#~mapCredentialItemPrice">mapCredentialItemPrice</a></li></ul></li><li><a href="module-support_asserts.html">support/asserts</a><ul class='methods'><li data-type='method'><a href="module-support_asserts.html#.assertAddress">assertAddress</a></li><li data-type='method'><a href="module-support_asserts.html#.assertAmount">assertAmount</a></li><li data-type='method'><a href="module-support_asserts.html#.assertCredentialItemPrice">assertCredentialItemPrice</a></li><li data-type='method'><a href="module-support_asserts.html#.assertCredentialItems">assertCredentialItems</a></li><li data-type='method'><a href="module-support_asserts.html#.assertCredentialItemType">assertCredentialItemType</a></li></ul></li><li><a href="module-support_errors.html">support/errors</a><ul class='methods'><li data-type='method'><a href="module-support_errors.html#~mapError">mapError</a></li></ul></li><li><a href="module-support_tx.html">support/tx</a><ul class='methods'><li data-type='method'><a href="module-support_tx.html#~assertCodeAtAddress">assertCodeAtAddress</a></li><li data-type='method'><a href="module-support_tx.html#~detectDeployedContract">detectDeployedContract</a></li><li data-type='method'><a href="module-support_tx.html#~getContractArtifact">getContractArtifact</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#destructArray">destructArray</a></li><li><a href="global.html#getTransactionPoolStatus">getTransactionPoolStatus</a></li><li><a href="global.html#handleSendError">handleSendError</a></li><li><a href="global.html#searchTxPoolContentResult">searchTxPoolContentResult</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#sendChain">sendChain</a></li><li><a href="global.html#sendPlatformCoin">sendPlatformCoin</a></li><li><a href="global.html#sendRawTransaction">sendRawTransaction</a></li><li><a href="global.html#sendTransaction">sendTransaction</a></li><li><a href="global.html#signAndSend">signAndSend</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">escrow.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module escrow
 *
 * @description Exposes the CvcEscrow contract interface. Functions to place, release and refund escrow payments
 * as well as administrative functions to set and retrieve the platform fee and escrow payment timeout thresholds.
 */
const escrow = {};
module.exports = escrow;

/**
 * @description The escrow contract placement state.
 * @typedef {Object} PlacementDetails
 * @property {number} amount - The placement amount in CVC.
 * @property {number} paymentState - The placement state: 0 ='Empty', 1 = 'Placed', 2 = 'Released', 3 = 'Canceled'.
 * @property {Array&lt;string>} credentialItems - An array of credential item IDs.
 * @property {number} confirmations - Number of confirmations
 * i.e. blocks passed since the block with placement transaction.
 * @property {bool} canRefund - The placement refundability status:
 * false - the placement is not refundable,
 * true - the placement can be refunded.
 */

const _ = require('lodash');
const tx = require('./support/tx');
const sender = require('./support/sender');
const { toCVC } = require('./token');
const { CVC_DECIMALS, CONTRACT_TOKEN, CONTRACT_ESCROW } = require('./support/constants');
const logger = require('./logger');
const { assertAddress, assertAmount, assertCredentialItems } = require('./support/asserts');
const ontology = require('./ontology');

// Default gas limits per transaction type:
const PLACE_GAS_LIMIT = 250000;
const RELEASE_GAS_LIMIT = 100000;
const REFUND_GAS_LIMIT = 100000;

/**
 * @description Generates a list of transactions that must be made in order to place CVC into escrow.
 *
 * If the sourceAddress has already pre-approved a CVC transfer balance to the escrow contract greater than the
 * amount of the placement, then we can make the placement directly.
 *
 * If the sourceAddress has not pre-approved, then we need to make an approve transaction on the CvcToken contract.
 * If the sourceAddress has pre-approved, but the amount is not sufficient, then we need to first drop the allowance
 * to zero (https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729) and then make an approve transaction.
 *
 * @param {object} contracts An object containing CvcEscrow &amp; CvcToken contracts
 * @param {string} sourceAddress The address of the account making the escrow placement
 * @param {string} recipientAddress The recipientAddress of the escrow payment (once released)
 * @param {Array&lt;string>}  scopeRequestIds The scope request IDs to which the escrow payment refers
 * @param {number} amount The amount of creds to put in escrow
 * @param {Array} credentialItems An array of ontology record IDs
 * @return {Array} The transactions that need to be executed (in sequence) in order to make escrow placement
 */
const createEscrowPlaceTransactions = (
  contracts,
  sourceAddress,
  recipientAddress,
  scopeRequestIds,
  amount,
  credentialItems
) => {
  const allowancePromise = contracts.CvcToken.allowance(sourceAddress, contracts.CvcEscrow.address);

  /**
   * @description Creates a set of CVC approve transactions to ensure the batch placements can be successfully made.
   * ERC20 tokens require a two step transfer process.
   * 1) Approve CVC transfer of X from A to B (token.approve). Triggered by A (the requester in this case)
   * 2) Transfer up to X CVC from A to B (token.transferFrom). Triggered by B (the escrow contract)
   *
   * If the current approved amount is zero, approve X. (one transaction)
   *
   * If the current approved amount is non-zero but less than X, then this function
   * reduces the approved balance to zero and re-approves X CVC.
   * contract does not allow topping up a non-zero approval balance.) (two transactions)
   *
   * If the current approved amount is greater than X, add nothing. (zero transactions)
   *
   * @param {number} allowance The current approved amount from the requester to the escrow contract.
   * @return {Array} A list of 0, 1 or 2 approval transactions.
   */
  const approveTransactions = allowance => {
    logger.debug('approveTransactions current allowance', {
      allowance,
      contractAddress: contracts.CvcEscrow.address,
      sourceAddress,
      scopeRequestIds
    });

    const approvalTransactions = [];

    if (allowance.eq(0)) {
      // fromAddress has not approved any CVC into the escrow contract. We need to send an approve transaction first
      approvalTransactions.push({
        contract: CONTRACT_TOKEN,
        method: 'approve',
        args: [contracts.CvcEscrow.address, amount]
      });
    } else if (allowance.lt(amount)) {
      // fromAddress has approved CVC to the escrow contract, but it is not sufficient for the escrow payment.
      // We need to top up the allowance.
      // since the CVC ERC20 token contract does not allow topping up a non-zero approval balance,
      // this means we must first reduce the allowance to zero and then top up
      approvalTransactions.push({
        contract: CONTRACT_TOKEN,
        method: 'approve',
        args: [contracts.CvcEscrow.address, 0]
      });
      approvalTransactions.push({
        contract: CONTRACT_TOKEN,
        method: 'approve',
        args: [contracts.CvcEscrow.address, amount]
      });
    } // else allowance >= amount - we have enough for the batch escrow placements

    return approvalTransactions;
  };

  /**
   * @description Creates the placement transaction and returns as a single element array
   * to be chained to other transaction creators.
   * @return {object} Escrow placement transaction params.
   */
  const placementTransactions = () => [
    {
      contract: CONTRACT_ESCROW,
      method: 'placeBatch',
      args: [recipientAddress, scopeRequestIds, amount, credentialItems]
    }
  ];

  /**
   * @description Calls a transaction creator and adds the result to a (possibly empty) list)
   * @param {function} transactionCreator - A function which returns transaction params.
   * @return {function(*=): Array} - Curried function that, given a transaction creator,
   * concatenates its result to a passed in (possibly empty) list
   */
  const addToList = transactionCreator => (list = []) => [...list, ...transactionCreator()];

  const createApproveTransactions = allowance => addToList(() => approveTransactions(allowance))();
  const addPlacementTransactions = addToList(placementTransactions);

  return allowancePromise.then(createApproveTransactions).then(addPlacementTransactions);
};

/**
 * @description Adds escrow function return value and transaction receipt to resulting object.
 * @param {object} transactionReceipt - The blockchain transaction result.
 * @param {string} fromAddress - The transaction sender address.
 * @param {string} idvAddress - The identity validator address.
 * @param {Array&lt;string>} scopeRequestIds - An array of scope request identifiers.
 * @returns {object} A promise of transaction hash (see tx.js module) and returnValue object with placementId.
 */
async function addPlacementReturnValue(transactionReceipt, fromAddress, idvAddress, scopeRequestIds) {
  const response = {
    returnValue: {},
    ...transactionReceipt
  };

  if (!_.isEmpty(scopeRequestIds)) {
    response.returnValue.placementId = await escrow.calculatePlacementId(fromAddress, idvAddress, scopeRequestIds);
  }

  return response;
}

/**
 * @alias module:escrow.place
 * @memberOf escrow
 * @description Places CVC tokens into escrow smart contract.
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {string} idvAddress - The identity validator address.
 * @param {string} scopeRequestId - Scope request identifier.
 * @param {number} amount - CVC token amount in creds (CVC x 10e-8).
 * @param {Array&lt;string>} credentialItems - Array of credential item IDs.
 * @param {object} txOptions - transaction options.
 * @param {number} [txOptions.nonce] - The transaction sequence number.
 * @param {number} [txOptions.gas] - The gas value provided by the sender.
 * @param {number} [txOptions.gasPrice] - The gas price value provided by the sender in Wei.
 * @param {number} [txOptions.chainId] - The network chain id according to EIP-155.
 * @param {number} [txOptions.waitForMineTimeout] - Max time to wait for transaction receipt before raising an error.
 * @returns {Promise&lt;object>} A promise of the transaction hash (see tx.js module)
 * and returnValue object with placementId.
 */
escrow.place = function(fromAddress, signTx, idvAddress, scopeRequestId, amount, credentialItems, txOptions = {}) {
  return escrow.placeBatch(fromAddress, signTx, idvAddress, [scopeRequestId], amount, credentialItems, txOptions);
};

/**
 * @alias module:escrow.placeBatch
 * @memberOf escrow
 * @description Places CVC tokens into escrow smart contract.
 * Allows the batching of scope request IDs to reduce transaction costs.
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {string} idvAddress - The identity validator address.
 * @param {Array&lt;string>} scopeRequestIds - An array containing scope request identifiers.
 * @param {number} amount - CVC token amount in creds (CVC x 10e-8).
 * @param {Array&lt;string>} credentialItems - Array of credential item IDs.
 * @param {object} txOptions - transaction options.
 * @param {number} [txOptions.nonce] - The transaction sequence number.
 * @param {number} [txOptions.gas] - The gas value provided by the sender.
 * @param {number} [txOptions.gasPrice] - The gas price value provided by the sender in Wei.
 * @param {number} [txOptions.chainId] - The network chain id according to EIP-155.
 * @param {number} [txOptions.waitForMineTimeout] - Max time to wait for
 * transaction receipt before raising an error.
 * @returns {Promise&lt;object>} A promise of the transaction hash (see tx.js module)
 * and returnValue object with placementId.
 */
escrow.placeBatch = async function(
  fromAddress,
  signTx,
  idvAddress,
  scopeRequestIds,
  amount,
  credentialItems,
  txOptions = {}
) {
  assertAddress(fromAddress);
  assertAddress(idvAddress);
  assertAmount(amount);
  assertCredentialItems(credentialItems);

  // Merge txOptions
  const updatedTxOptions = _.defaults({}, txOptions, { gas: PLACE_GAS_LIMIT });

  // Logging
  const normalizedIds = scopeRequestIds.map(normalizeScopeRequestId);
  logger.debug('Placing escrow', {
    fromAddress,
    idvAddress,
    scopeRequestIds,
    normalizedIds,
    amount: toCVC(amount).toFixed(CVC_DECIMALS),
    credentialItems,
    txOptions: updatedTxOptions
  });

  // Prepare contract and credential item IDs promises to resolve them in parallel.
  const contractsPromise = tx.contractInstances(CONTRACT_TOKEN, CONTRACT_ESCROW);
  const internalIdsPromise = Promise.all(
    credentialItems.map(ontology.parseExternalId).map(args => ontology.getIdByTypeNameVersion(...args))
  );

  const [contracts, internalIds] = await Promise.all([contractsPromise, internalIdsPromise]);
  const transactions = await createEscrowPlaceTransactions(
    contracts,
    fromAddress,
    idvAddress,
    normalizedIds,
    amount,
    internalIds
  );

  if (transactions &amp;&amp; transactions.length > 1) {
    logger.debug('More than one transaction batched during escrow place ', {
      fromAddress,
      idvAddress,
      transactions,
      scopeRequestIds
    });
  }

  const receipt = await sender.sendChain({
    fromAddress,
    signTx,
    transactions,
    txOptions: updatedTxOptions
  });

  return addPlacementReturnValue(receipt, fromAddress, idvAddress, scopeRequestIds);
};

/**
 * @alias module:escrow.release
 * @memberOf escrow
 * @description Releases placed CVC tokens from escrow contract.
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {string} scopeRequestId - Scope request identifier.
 * @param {object} txOptions - transaction options.
 * @param {number} [txOptions.nonce] - The transaction sequence number.
 * @param {number} [txOptions.gas] - The gas value provided by the sender.
 * @param {number} [txOptions.gasPrice] - The gas price value provided by the sender in Wei.
 * @param {number} [txOptions.chainId] - The network chain id according to EIP-155.
 * @returns {Promise&lt;object>} A promise of the transaction hash (see tx.js module)
 * and returnValue object with placementId.
 */
escrow.release = function(fromAddress, signTx, idrAddress, idvAddress, scopeRequestId, txOptions = {}) {
  return escrow.releaseBatch(fromAddress, signTx, idrAddress, idvAddress, [scopeRequestId], [], txOptions);
};

/**
 * @alias module:escrow.releaseBatch
 * @memberOf escrow
 * @description Releases placed CVC tokens from escrow contract.
 * Allows the batching of scope request IDs to reduce transaction costs.
 * Also allows partial release by providing the list of scope request IDs which should be kept in escrow.
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {Array} scopeRequestIdsToRelease - An array of scope request IDs which will be released.
 * @param {Array} scopeRequestIdsToKeep - An array of scope request IDs which will be kept in escrow.
 * @param {object} txOptions - transaction options.
 * @param {number} [txOptions.nonce] - The transaction sequence number.
 * @param {number} [txOptions.gas] - The gas value provided by the sender.
 * @param {number} [txOptions.gasPrice] - The gas price value provided by the sender in Wei.
 * @param {number} [txOptions.chainId] - The network chain id according to EIP-155.
 * @returns {Promise&lt;object>} A promise of the transaction hash (see tx.js module)
 * and returnValue object with placementId.
 */
escrow.releaseBatch = async function(
  fromAddress,
  signTx,
  idrAddress,
  idvAddress,
  scopeRequestIdsToRelease,
  scopeRequestIdsToKeep,
  txOptions = {}
) {
  assertAddress(fromAddress);
  assertAddress(idrAddress);
  assertAddress(idvAddress);

  // Merge txOptions
  // gas limit has to be adjusted in case of partial release, as it issues a new placement on the blockchain
  const updatedTxOptions = _.defaults({}, txOptions, {
    gas: scopeRequestIdsToKeep.length ? RELEASE_GAS_LIMIT + PLACE_GAS_LIMIT : RELEASE_GAS_LIMIT
  });

  const normalizedScopeRequestIdsToRelease = scopeRequestIdsToRelease.map(normalizeScopeRequestId);
  const normalizedScopeRequestIdsToKeep = scopeRequestIdsToKeep.map(normalizeScopeRequestId);
  logger.debug('Releasing batch escrow', {
    fromAddress,
    idrAddress,
    idvAddress,
    scopeRequestIdsToRelease,
    scopeRequestIdsToKeep,
    normalizedScopeRequestIdsToRelease,
    normalizedScopeRequestIdsToKeep,
    txOptions: updatedTxOptions
  });

  const receipt = await sender.send({
    fromAddress,
    signTx,
    contractName: 'CvcEscrow',
    method: 'releaseBatch',
    params: [idrAddress, idvAddress, normalizedScopeRequestIdsToRelease, normalizedScopeRequestIdsToKeep],
    txOptions: updatedTxOptions
  });

  return addPlacementReturnValue(receipt, idrAddress, idvAddress, normalizedScopeRequestIdsToKeep);
};

/**
 * @alias module:escrow.verify
 * @memberOf escrow
 * @description Verifies escrow placement state.
 * This is read-only method and doesn't involve transaction mining.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {string} scopeRequestId - Scope request identifier.
 * @returns {PlacementDetails} A promise of the escrow placement details.
 */
escrow.verify = function(idrAddress, idvAddress, scopeRequestId) {
  return escrow.verifyBatch(idrAddress, idvAddress, [scopeRequestId]);
};

/**
 * @alias module:escrow.verifyBatch
 * @memberOf escrow
 * @description Verifies state of the batched escrow placement.
 * This is read-only method and doesn't involve transaction mining.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {Array&lt;string>} scopeRequestIds - An array of scope request identifiers.
 * @returns {PlacementDetails} A promise of the escrow placement details.
 */
escrow.verifyBatch = async function(idrAddress, idvAddress, scopeRequestIds) {
  assertAddress(idrAddress);
  assertAddress(idvAddress);

  const normalizedIds = scopeRequestIds.map(normalizeScopeRequestId);
  const escrowContract = await tx.contractInstance(CONTRACT_ESCROW);
  logger.debug('Verifying escrow payment: ', {
    idrAddress,
    idvAddress,
    scopeRequestIds,
    normalizedIds
  });

  const verification = await escrowContract.verifyBatch(idrAddress, idvAddress, normalizedIds);
  logger.debug('Escrow payment verified: ', mapVerifyResult(verification));

  return verification;
};

/**
 * @alias module:escrow.verifyPlacement
 * @memberOf escrow
 * @description Returns escrow placement details by placementId.
 * This is read-only method and doesn't involve transaction mining.
 * @param {string} placementId - The escrow placement ID.
 * @returns {PlacementDetails} - A promise of the escrow placement details.
 */
escrow.verifyPlacement = async function(placementId) {
  const escrowContract = await tx.contractInstance(CONTRACT_ESCROW);
  logger.debug(`Verifying placement: ${placementId}`);

  return escrowContract.verifyPlacement(placementId);
};

/**
 * @alias module:escrow.refund
 * @memberOf escrow
 * @description Refunds escrowed funds to identity requester account.
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {string} scopeRequestId - Scope request identifier.
 * @param {object} txOptions - transaction options.
 * @param {number} [txOptions.nonce] - The transaction sequence number.
 * @param {number} [txOptions.gas] - The gas value provided by the sender.
 * @param {number} [txOptions.gasPrice] - The gas price value provided by the sender in Wei.
 * @param {number} [txOptions.chainId] - The network chain id according to EIP-155.
 * @returns {Promise&lt;object>} A promise of the transaction hash (see tx.js module)
 * and returnValue object with placementId.
 */
escrow.refund = function(fromAddress, signTx, idrAddress, idvAddress, scopeRequestId, txOptions = {}) {
  return escrow.refundBatch(fromAddress, signTx, idrAddress, idvAddress, [scopeRequestId], txOptions);
};

/**
 * @alias module:escrow.refundBatch
 * @memberOf escrow
 * @description Refunds escrowed funds for batch placement.
 * Allows the batching of scope request IDs to reduce transaction costs.
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {Array&lt;string>} scopeRequestIds - An array containing scope request identifiers.
 * @param {object} txOptions - transaction options.
 * @param {number} [txOptions.nonce] - The transaction sequence number.
 * @param {number} [txOptions.gas] - The gas value provided by the sender.
 * @param {number} [txOptions.gasPrice] - The gas price value provided by the sender in Wei.
 * @param {number} [txOptions.chainId] - The network chain id according to EIP-155.
 * @returns {Promise&lt;object>} A promise of the transaction hash (see tx.js module)
 * and returnValue object with placementId.
 */
escrow.refundBatch = function(fromAddress, signTx, idrAddress, idvAddress, scopeRequestIds, txOptions = {}) {
  // Merge txOptions with default
  const updatedTxOptions = _.defaults({}, txOptions, { gas: REFUND_GAS_LIMIT });
  const normalizedIds = scopeRequestIds.map(normalizeScopeRequestId);

  logger.debug('Refunding escrow', {
    idrAddress,
    idvAddress,
    scopeRequestIds,
    normalizedIds,
    txOptions: updatedTxOptions
  });

  return sender.send({
    fromAddress: assertAddress(fromAddress),
    signTx,
    contractName: CONTRACT_ESCROW,
    method: 'refundBatch',
    params: [assertAddress(idrAddress), assertAddress(idvAddress), normalizedIds],
    txOptions: updatedTxOptions
  });
};

/**
 * @alias module:escrow.setTimeoutThreshold
 * @memberOf escrow
 * @description Changes the escrow timeout threshold. Expects integer - number of blocks. Admin only
 * If a payment stays in escrow longer than this threshold, the placement can no longer be
 * released, but must be refunded
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {number} threshold - Number of blocks after which an escrow placement can be canceled (refunded).
 * @return {Promise&lt;{ transactionHash: string }>} A promise of the transaction hash.
 */
escrow.setTimeoutThreshold = function(fromAddress, signTx, threshold) {
  logger.debug('Setting the escrow contract timeout threshold', {
    fromAddress,
    threshold
  });
  return sender.send({
    fromAddress: assertAddress(fromAddress),
    signTx,
    contractName: CONTRACT_ESCROW,
    method: 'setTimeoutThreshold',
    params: [threshold]
  });
};

/**
 * @alias module:escrow.timeoutThreshold
 * @memberOf escrow
 * Returns the current value of placement release timeout threshold.
 * @return {Promise&lt;number>} A promise of the timeout threshold value.
 */
escrow.timeoutThreshold = function() {
  return tx.contractInstance(CONTRACT_ESCROW).then(escrowContract => escrowContract.timeoutThreshold());
};

/**
 * @alias module:escrow.setFeeRate
 * @memberOf escrow
 * @description Updates marketplace platform escrow fee rate
 * i.e. the percentage of escrow placement amount which is transferred
 * to platform administrator address upon each placement release. Admin only
 * @param {string} fromAddress - The transaction sender address.
 * @param {function} signTx - Transaction signing function.
 * @param {number} feeRate - The marketplace platform escrow fee rate.
 * @return {Promise&lt;{ transactionHash: string }>} A promise of the transaction hash.
 */
escrow.setFeeRate = function(fromAddress, signTx, feeRate) {
  logger.debug('Setting the escrow contract platform fee rate', {
    fromAddress,
    feeRate
  });
  return sender.send({
    fromAddress: assertAddress(fromAddress),
    signTx,
    contractName: CONTRACT_ESCROW,
    method: 'setFeeRate',
    params: [feeRate]
  });
};

/**
 * @alias module:escrow.calculatePlacementId
 * @memberOf escrow
 * @description Calculates escrow placement ID from a set of scope request IDs. This
 * allows a client to identify the batch that an array of scope requests was added to.
 * @param {string} idrAddress - The identity requester address.
 * @param {string} idvAddress - The identity validator address.
 * @param {Array&lt;string>} scopeRequestIds - An array of scope request identifiers.
 * @return {string} A promise of the escrow placement ID.
 */
escrow.calculatePlacementId = async function(idrAddress, idvAddress, scopeRequestIds) {
  const escrowContract = await tx.contractInstance(CONTRACT_ESCROW);
  logger.debug('Calculating placementId: ', { idrAddress, idvAddress, scopeRequestIds });
  return escrowContract.calculatePlacementId(idrAddress, idvAddress, scopeRequestIds);
};

function toPaymentState(number) {
  // this array should be kept in sync with CvcEscrowInterface.sol
  return ['Empty', 'Placed', 'Released', 'Canceled'][number];
}

function mapVerifyResult([amount, paymentState, credentialItems, confirmationsNumber, canRefund]) {
  return {
    amount: toCVC(amount).toFixed(CVC_DECIMALS),
    paymentState: toPaymentState(paymentState.toNumber()),
    credentialItems,
    confirmations: confirmationsNumber.toNumber(),
    canRefund
  };
}

/**
 * Normalizes provided scope request ID to be compatible with Solidity bytes32: 0x + 64 hex chars.
 * @param {string} scopeRequestId - A scope request ID.
 * @returns {string} Normalized scope request ID.
 */
function normalizeScopeRequestId(scopeRequestId) {
  if (scopeRequestId.match(/^0x[0-f]{64}$/)) {
    // Scope request ID is normalized already
    return scopeRequestId;
  }

  // Convert to lower case, strip all non 0-9a-f (hex) chars, take first 64 chars:
  const extracted = scopeRequestId
    .toLowerCase()
    .replace(/[^ 0-9a-f]/g, '')
    .substr(0, 64);
  // Pad with 0 from the left till 64 chars, prepend 0x:
  return `0x${_.padStart(extracted, 64, '0')}`;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Jan 14 2019 16:11:52 GMT+0200 (EET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
